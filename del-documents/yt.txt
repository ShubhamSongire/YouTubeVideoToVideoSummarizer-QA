for the past 6 months I haven't been using email rather I've been using this AI agent to check email for me it drafts responses it schedules meetings I'm still in the loop it's still very human in the loop but the idea is I have this AI agent that's monitoring my email inbox and it's alerting me when there's things I should see or when there's drafts of emails that I should approve or anything like that so in this video I want to walk through how to run this yourself um as well as some of the design decisions behind what went into
the agent behind it this is a very developer Centric video you will be running code uh writing code using the raw apis themselves if you want to just see how to use this agent there's a separate video for that in the links below but if you're here as a developer wanting to learn how to build an email assistant like this let's Dive In I'm here in GitHub at the eia repository that stands for executive AI assistant and the first thing I'm going to do is I'm going to Fork this because I might be making changes that I
want to push back up to a GitHub repo let's go ahead and Fork this I'll leave it all the same and let's create the fork now that this has been forked I'm going to clone it locally let's open it up in pie charm great I've got to read me here let's now walk through how to set this up and run it so I already did this um I'm now going to create a virtual environment for this awesome I'm going to activate that virtual environment and now I'm going to pip
install a whole bunch of dependencies Next Step I'm going to set up some credentials so I need an openai API key this will be used to interact with open ai's llms I need an anthropic API key because Claude Sona is a great model and I want to interact with that model as well I need a langing Smith API key this will be used for tracing debugging but also to run the agent server that's running my agents and then finally I need Google credentials so this is used to access my Gmail and my calendar so these three are just API
keys that you can set in your environment this Google one is a little bit trickier so let's go to this link all right so there's some steps that I need to follow to authorize credentials for a desktop application follow those here we're then going to go back here and we're going to create this Secrets repository where I'm going to put some Secrets related to Google after you've done everything in the UI you should have downloaded the client secret you're then going to take the Json that you should have downloaded as
part of the previous step and move it into here so for me this is what this file looked like and I need to name this secrets. Json I'm then going to run this Command right here this is going to ask me to log in to my email and authorize it it's going to ask for access to my calendar and to my Gmail great after this if I go back I should see that in Secrets there is now a token.
Json this is my o token that I'm going to use before going on make sure that you've exported these API keys to their respective variables I am not going to do this live on video but you should make sure that you have done that the next step is configuration later in the video I'm going to walk through the code and what everything means for now I'm just going to configure the agent in a no code way so I'm going to go to this yaml file and open it I'm going to see a bunch of fields in this file this is where I can configure the agent to give it
background information and tell it how to behave let's go through the fields first up is email I've redacted mine for now but this is where you'll put the email address that you want to monitor next full name then the name you like to be called some background information on yourself and now we start getting into the preferences of the agent how it should respond how it should schedule things so this can be things like meeting length any background preferences or or pieces of information is maybe a more apt description so this
is used generically when responding so if you wanted to know who important people are or important addresses are you can put that here time zone this is mainly used for scheduling events um rewrite preferences this is used for rewriting the email so we'll go into the flow a little bit down the road uh but basically what happens is when we draft an email we then have an explicit step that rewrites it to really focus on matching the tone that you like and so you can express that here then we have instructions for how to triage emails
and so these are emails that we do not want to respond to this is triage no triage notify is emails that we want to be notified about and then triage email is emails that we want to respond to and then finally we have memory equals true this configures memory we'll talk about that a lot later on as well great that's the configuration next up we're going to run it locally so the first thing we're going to do is install the Lang graph CLI and what this is going to do is this is going to let us run an agent server
locally next we're going to run Lang graph Dev and this will spin it up in a local python instance we can see that it opens up lra Studio when it's finished if you haven't used lra Studio before I'll include some links in the description but basically this allows us to visualize and interact with our agent we're not going to dive into the agent right now but we'll return to the screen later on so we can walk through what the agent looks like if you want to sneak preview you can look at it here awesome what's up next now we want to
ingest some emails locally so this is going to kick off an inest job that's going to look at emails and send them through our local email assistant so what we need to do is we need to open up a new ter I'm going to go back into this directory I'm going to reactivate my virtual environment and then once I've done that I'm going to kick off an injust job and I'm going to run it for the past let's say 4 hours what these flags mean minute sense is how many minutes to run it um and this will look at all emails that have arrived in in in these
last uh 240 minutes rerun is going to be rerunning for any emails that it has already kind of like seen and early means it's just going to keep on going even if it sees emails that has already seen so this is just doing a full rerun of all emails let's kick this off so we can see that actually failed on one I need to look into this to see what's going on it's failed on a few um I'll I'll debug that separately um and if we go over here we can see that there is a bunch of stuff happening and these this is the agent now kind of like
running in the backg ground we can now set up the agent inbox with this local agent so let's go to this URL this is where I can access the agent inbox and I can now set up a new inbox so what I can do is I'm going to add the graph ID of main main is the main assistant there's actually a few other graphs we'll talk talk about that later on but I'm going to add that there I'm then going to add this as the URL because this is where it's running locally and I'm going to name this yay Dev let's submit this and I can see here
that I now have a few emails that require my attention now you may be wondering why there's so many actions here that require our attention isn't this an agent that we just launched what's what's going on well so this is an agent that's really focused on human in the loop and so I want to be in the loop anytime it does something for a few reasons one I don't quite trust it yet I don't I don't trust it to email autonomously or schedule calendar invites completely on my behalf it can definitely write drafts and it can it
can create a plan to schedule something and you can see in the other video that I'll link to in the description of how to interact with this agent but I can then just like click accept and so it's super easy it speeds it up but I don't fully trust this that reason one reason two is this human agent collaboration is great this back and forth is fantastic because the agent can learn from that and start to develop long-term memory and so I really do want to interact with it just like I would interact with an EA
or a human so that they can start to get a sense of who I am what I like how I want to respond to emails things like that so we've just deployed this locally and that's great but my email is not always running it's not always on and so I want to deploy this in a more production ready way and so in order to do that I going to deploy it on lingraph cloud so what I'm going to do is I'm going to go to lsmith I'm going to go to lingraph platform here and I'm going to click new deployment it's connected to my GitHub
and I'm going to select the repo that we just created I'm going to name it EA for video uh I'm going to point it to the main branch I'm going to point it to this Lang graph. Json we'll talk about that in a second when we talk and walk through the code development is fine I'm going to add in a bunch of environment variables and so I'm not going to do that but these are the open AI key the anthropic key I don't need to add my langing chain or Lang Smith key because that will be automatically loaded for me and then I need to load
these two extra ones so I've got these two files here these are basically my Gmail secret and The Oaf token and what I want to do is I want to take the value vales of these and add these as environment variables to the deployment so I'm not going to do that live but basically you can do that by adding them here and then you can click submit and it will go ahead and deploy it after you've deployed it it should look something like this you probably won't have this traffic I've had this deployed for a little bit now if we go
back here the next thing in the step is to kick off and ingest manually this will kick off a manual in just job I'm not going to do that because I've done something that we'll talk about later on on how I can set up a Cron job already but you can run this if you want this will do the same thing as it did locally we then want to connect this deployed agent with our agent inbox so I can go back to the agent inbox here and here we had this Dev we can see here that I've now connected it to the production deployment and so the way to do that is
you go in settings you should make sure you have your API key here you didn't need this when you were running it locally you do need it now you click add an inbox you use main again as the URL and then you come in here you take your API URL here copy that you can put that here and then give it another name and it will show up here so you can add your deployed agent to your inbox in this way then the last thing thing that we're going to cover is setting up a cron drop so you don't want to run this manual inest all the time that's really
annoying you want it running in the background so you can do that by running this command here so you're going to take that URL which we just found and then run this python Command right here that'll set up a crown job that Cron job will run every 10 minutes and it will check your inbox for new emails and then deal with them accordingly all right so we set up the email assistant we've got it running let's now walk through the code and explain in a little bit more detail what exactly is going on so to start let's
take a look at the L graph. Json this is where we Define our agents we can see that there's actually a few things in here so in graphs there's actually four graphs the primary one that we're going to care about is main but we'll talk about these other ones as well we can see that in addition to the graphs there's also the store configuration this configures support for semantic search within our long-term memory store so if you're using memory there are some cases where we're going to be doing semantic search over contents of that
and we'll talk about where those are later on but this configures how those are run so I'm using open ai's text embedding three small model at the top level there's not too much else we've got this scripts directory and we'll talk through what's in there we've already used some of these we've got this EA a IIA directory and we'll talk through that in detail and then there's the only other thing that's maybe worth looking at is p project.
Tomo this just lays out all the dependencies that you can that we need so you can see that we have Lang graph we've got the checkpointing library within L graph we've got some Lan chain open AI anthropic packages we've got a bunch of Google stuff for interacting with Gmail um and then some other stuff which is useful for dates the dependencies are pretty light so let's jump into the code let's first look in eai there's a few things within here there's this main directory this contains all the logic for the main graph and there's a bunch in here and so we'll walk
through this there's two other files that are related to graphs this is cron graph and this is reflection graphs. piy and so if you remember in L graph. Json we had these other graphs here those are going to be in these other python files we'll talk about those at the end before we jump in to the main agent let's look very quickly at schemas dop so this contains a bunch of schem related to the state of our agent or agents as well as uh some typed dicks or some pantic models that we're going to use to structure the agent's output in
various points we've also got this gmail. if we clicking here there are a lot of helper functions related to parsing emails sending emails uh parsing parts of emails and so there's a lot of helper functions in here for basically just dealing with Gmail and calendars some of these are helper functions some of these are tools all right let's take a look at the main agent there's a bunch of files in here and if we click into graph.
pi and scroll to the bottom this is where the graph is compiled and built as you might notice there are a lot of nodes and a lot of edges rather than walk through these in code I'm going to use Lang graph Studio to get a visual representation of what's going on then I'll return here and talk through the specific python files and how they match up so I'm going to go over here if I click l graph Studio I can see here a visualization of the agent so start is the place where we start the email comes in and it hits this node and it goes
right away to triage input so here we're triaging the email that we are dealing with one thing it can do is it can go to this Mark as red node this will basically mark the email as red and then finish so it's pretty straightforward another relatively simple thing it can do is it can go to notify so triage input is using an llm and that's how it's determining how to go and if it determines that an email is worth notifying us for then from there it will go to human node the way to think about human node is this basically matches up
with the agent inbox with which we saw so you can see here that I have a notify so from here it interrupts the graph and we'll talk through how it does that but it interrupts the graph it sends something to agent inbox and it waits for our response the third thing that this triage input node can do is it can send to this draft response node this is the main email agent that has access to more tools and tries to write emails and so let's walk through that we can see that there are a lot of branches from here one it could decide to send a message
sending a message is not sending a message to the recipient but rather sending a message to me the user and so if we go back here we can see that we have some questions this is where the agent decided here that it wanted to ask me a question about how to respond another place that this can go is over here to find meeting time so we'll talk about this in more detail but find meeting time is actually a sub agent that has some tools and so this will find a meeting time from here it can also send a calendar invite so the
way that it basically works is this main agent can call the sub agent it finds a time then this it goes back to this main agent and this main agent can send a calendar invite another path that it has is this rewrite thing so you can see here that there's this sequence rewrite and then send email draft so basically what's going on is I have an explicit rewrite step for all emails that I want to write because I do not trust I've I've done some prompt engineering and basically this if this tries to think about what to do and
think about the tone to write the email in it doesn't produce good results so this just drafts a draft and then there's an explicit rewrite step and then this as it continues will go to the step where it tries to send the email there are a few more places that go into the human node send message it goes to the human node because it goes to agent inbox email draft goes to the human node because it wants me to approve it send calendar invite it goes to the human node because it wants me to approve it the last thing that this main
agent can do is it can basically go to this tool node which is used for when it has a bad tool name when the agent has hallucinated a tool to use this can happen because the instructions that it has are pretty complex and so it might mess up so it goes here and then it will come back in with some self-healing from the human node so after the agent inbox you can see that there are a few paths it can go on so one it can mark it as red so when I press ignore in the agent inbox what's happening is it's going back into the graph it's picking
up from here and it's going to this Markus red node it can also actually send the calendar so you know send Cal invite this is just drafting an invitation a calendar invitation to send this is where it actually happens after it actually sends the calendar invite it then goes back to the main agent and so it can continue and usually say something like hey I just sent a calendar invite something like that send email node will then go to the mark as red node and then it will finish so the sending of the email is the last thing
that this agent generally does and so one Improvement if you wanted would be the ability to have it send an email and then go back to this main agent and then send a calendar or send another email or something like that but at the moment that's not supported so that walks through what this agent does at a high level hopefully that's helpful now let's walk through the code to see how exactly it's done so this is where the agent is defined there's not a ton of logic in here there's uh some basic routing logic so this takes in the triage step and and
and goes onto other things but there's not a ton in here it's basically a bunch of conditional edges in dealing with bad tool names and that's basically it conditional edges are defined in this file let's kind of go through it in order so let's go to the triage node first so this is the agent responsible for triaging if we scroll down here we can see that there's this really complicated prompt which we're formatting with a bunch of information um we're getting some few shot examples so I'll talk about this when memory
happens a little bit later on but basically we're getting this prompt we're getting some f shot examples we're using open AI here and then we are doing uh structured output generation and so we're using this respond to schema if we go here we can see here that the llm is generating logic and then response and so the response types can be no email notify or question question is something that's not handled so this is a legacy thing that I actually experimented a little bit with but basically didn't see a ton of use in the reason being it's pretty
similar to notify so no is like ignore it email is send an email and then notify is notify Harrison question was supposed to be like if the agent didn't know what to do it could generate a question and send it to Harrison as well that's very similar to notify and so I saw in practice that the agent would always just kind of like notify me and so this isn't really used that's pretty much it the only other interesting thing to maybe call out here is this delete messages step so as I mentioned the triage input is the first thing that
happens now the way that I handle email threads is that it actually continues on the same thread as before but what I want to do is I want to wipe any previous conversation that I had with the agent before continuing with a follow-up email now you can argue whether this is the right thing to do or not I think in practice what I would want is actually to create a summary of the of the conversation that I had with the email agent um and then save that but right now I'm basically just clearing all the messages that come in so I'm adding the
remove message signals to the state update and then I'm updating the triage part of the state with the response okay so that's the triage step after that I'm not going to talk about notify because I'm going to talk about that in the agent inbox so let's go in to this main draft response Pi so this is the main agent part right here where it can Loop and do a bunch of stuff and so we can see that there are some pretty complex instructions here saying when to use tools we initialize a model we turn off parallel tool calling so I don't want
this to call multiple tools at a time I just want it to call one this was mainly just to make the code easier I give it access to a bunch of tools so it has the ability to draft new emails respond emails send me a question ask the meeting assistant when I'm free and send a calendar invite and then if there are any messages in it I also give it the ability to ignore the email so the reason I do this is that the first time it enters this there won't be any messages and I don't want it to ignore the email because I previously just had
a whole step that decided that this was an email worth responding to but if what happens is this sends a message to me and and I say in the human node like hey this isn't really worth like responding to just ignore it I want this main thing to be able to ignore it and and not proceed and so basically what will happen is if there are these messages the messages represent back and fors between kind of like uh me and the agent then it will append this tool called ignore which it can call to ignore the email we can see here that I'm loading a
bunch of stuff from store so store is long-term memory and this will basically be used to to fetch long-term memory and so I'm loading it from there and then there there's some stuff this is this is basically uh checking if it exists in the store if it doesn't exist in the store then it's putting it in the store so it can update and and and fetch from it later on um it's constructing this prompt um it's constructing a message from this prompt and then it is calling an L it's binding the tools to the llm it's
calling the LM with these messages and then I have this little Loop here where basically if it doesn't call a tool so remember I when I configured the model I told it that it can't call parallel tools but I also said tool Choice equals to required so it has to call a tool and if for whatever reason it doesn't call a tool sometimes I saw that it messed up um or it called multiple despite prompting or despite the configuration the prompting wasn't good enough I guess and so if that happens then I just then I just go in this little Loop and then I
update the response the state with the with the response message okay so what do these tools actually do and where are they defined so new email draft this is defined in gmail. this is sending a new email this is responding to an email also in gmail. sending the calendar invite also in gmail.
asking a question this is in the human inbox stuff and actually so when this new email for all these things they're still human in the loop approving it and so all of them actually go through the human inbox and so this is a really important file and we'll go to that in a little bit first I want to talk through meeting assistant because this is actually a sub agent and so this is in fine meeting time.
piy we can see here that I have a complicated prompt so so this is actually the only agent that has access to the calendar and so if we look down here we can see that I have this this node defined here I load a model and then I create a react agent so this sub agent is actually a much simpler architect of agent it's just a react style agent and only has one tool get events for days if I go to this this is defined in gmail.
this is a tool that basically interacts with the the calendar itself so the main agent doesn't have access to this tool it can just call this sub agent which has access to this tool to do its work for it and I then create kind of like this input message and invoke the react agent with this with this message now the response that the react agent sends back is actually going to be a list of messages because it's going to do some tool calls it's going to build up state of of kind of like AI message tool call AI message tool call and then it's going
to finish with an AI message and so I'm getting the last message in that list of messages and then what I'm returning and remember this will be returned to the main agent so the main agent generated something like call this meeting assistant agent what it needs to get back it needs to get back a tool message so this agent is doing a bunch of work none of this is going to show up to the m agent what it's going to see is it's just going to see the response from the sub agent as a tool message itself so there's other prompting strategies you
could do here that gets into some like multi-agent communication and what's the best way to do this we have some other work on that that will be coming out but for now the way that I did it is I basically just constructed this tool message which the main agent needs to see as a response it needs to get this tool message as a response and the cont of this tool message is the response from the sub agent so that's kind of what's going on here so the other thing that I want to talk about before the human inbox is
rewrite so this is just rewriting the draft of an email and so we can see here that I have this rewrite prompt I load this model and then basically what I'm doing is I'm getting the previous tool call so the main agent called this tool to draft an email and as part of that it did have the content of the email and so I'm getting that so this is tool calls gets the first tool call gets the content ARG it gets this as a draft and I'm passing that in to the to the agent to rewrite the email now what is it getting back I'm
doing with structured output so it's getting back this rewrite email which has logic so Logic for the tone of the email and then it has the Rewritten content so it has the Rewritten content itself okay so what is it doing with that we can see here that it's updating the state with a message but what is this message notice that it has the same ID as the previous message that we got from the main agent so the main agent generated this tool call the tool call is a draft of an email that tool call has an ID we are
then adding a new message to this list which has the same ID and what will happen is in the state because they have the same ID the most recent one will overwrite the old one so this one's going to overwrite the previous tool call and then what's going to be in there is the new content that we generated from the response so here we can see that we have this list of tool calls this list of tool calls is the only thing that's not new right so previous message ID same content same tool calls different in the tool calls
what's different the ID is the same the name's the same all the args except for the content are the same the content is different the content is now this Rewritten content so basically what we're doing is we're having the main agent generate a tool call that corresponds to a draft of an email we're then having another agent take that tool call and update the content field in it so we're basically just updating a tool call all right so now let's check out the human inbox and this is where a lot of the human Loop interaction pattern
happens so we can see here that we have some schemas defined these are the schemas of how the agent communicates to the agent inbox and these are actually now in the Lang graph package themselves so I could import them from here this is an older project before that even existed so I had to find them here we now have this template so this is what shows up as details on the right hand side when you open an email in the agent inbox so when you open an email in the agent inbox you have the actions you can take on the left and some content on the
right this is the template in markdown that defines that content so we can see that we put the subject of the email at the top we then add this place to click here to view the email and then we put the information of the email itself so who it's to who it's from and the content of the email after that we have a few helper functions that aren't too important but then we get into the important things and these are notes so all of these these are nodes in the overall graph so this is the send message node now remember send message is when it sends
me the user a message not an email it sends me a question so what is it doing okay so we can see that it's getting the tool calls and it's getting the most recent run and we know that this will be the question tool call now it's creating this human interrupt thing and it's basically saying this is tool call name this will be question it's it's putting through so action request is basically what action we're looking to take so it's putting that here and this is the tool call of of of uh question and the arguments are the the
inputs I now have this config this is saying the humans allowed to ignore this it's allowed to respond to this it can't edit it because there's nothing this isn't a action that I am going to take this is an action for communicating with the user so there's nothing to edit and there's nothing to accept either and then this is the description that shows up on the right so it generates this request this is still a python dictionary it then does this interrupt passes in the request and gets back a response what's going on here so
interrupt is something we added in L graph this is basically the most upto-date way we have to do human in the loop what this you can think of this as basically similar to the input function in Python so if you were just running this in the command line you could use input and it would do something like that it would print this out to the command line you could type back in and then the response of what you type back in would be this response that's basically what's going on here we're interrupting we're sending a list of things we're getting
back a list of things we know that there's only one thing in the list so we're just going to get the first thing and then this is the response that we get back from the user so what is the response well the response is is some schema um and and there's a few types that this response can be and the type is represented as a key in in the object that we get back so we can see here that if we get back a response type of ignore what we're going to do that's signaling to us that's signaling to the agent that we want to ignore this thread that's
going on and so we're going to add a new message to the list of messages and we're going to simulate that that message is calling the tool called ignore and we'll see we'll see later on what comes after this and how we deal with that but that's basically saying okay we're going to add this new message that's mocking that's simulating as if we actually ignored the response the other type that it could be is a response so this is the response where I answer questions so it could ask me like do you want to go to this event and I
would type back in yes so what happens if I type that in well what happens is we are going to create this message and this message is the thing that get added to the state so we're creating this message and in that message it's going to be a tool call response and the content is going to be the the response content that I responded so the way that the main agent will see this is it will see a list of messages one is the main agent in AI message that calls a tool called question with the content being the question that it's asking and it
will get back a tool response and that tool response is what I type back in now the other thing you'll notice here is all of this fun logic so this is under the if memory Branch so as I mentioned memory is configurable if you choose to have on memory it will go down this path what's going on it's first calling the save email function what does this do let's check it out okay great so what it's doing is it's basically adding few shot examples of emails and how they should be triaged so here you can see that we get
the names space for working with our long-term memory store so that's this this is the long-term memory store we then look to see if this email is already in the store because there's just back and forth and this could actually be called several times only the first time that we hit this do we want to do anything so we look to see if this is already in the store if it's not in the store then we're going to add it to the store and so what we're going to do is we're going to add this data and it's going to have as input the uh email
content so this is so this is the content who it's from uh who it's to the subject things like that we're going to add that and then we're also going to add in the status that we want it to be so this is a this will be a few shot example in the future um and so remember how in the triage step I said that we were calling this function called get few shot examples if we go here we can see that this what this does is this actually searches the store for the same namespace where we are saving it in the agent inbox great so it's going to be fetching
those and it will'll be inserting those so here so this save email thing that we call this is saving it as a few shot example and we do this whether it's ignored or whether we get a response back now if we get a response back we have a lot of information we can work with we can use that response to maybe update some of our other instructions or some of our other background information and so what we do is we create this new state and we pass this to the to a reflection graph and I'm going to talk about that at the end but
basically we trigger this reflection graph with this response we get back okay now remember this is just what happens when I respond to a question from the agent there's other things I can do so let's take a look at this this is when the agent sends me a draft of an email to approve similar things going on I create this action request which is basically the actions and the arguments and now in the config I'm allowed to ignore it I'm allowed to respond to it I can also edit it and I can also accept it okay so now what happens in all those
things if I respond to it we see uh a similar thing we create a message but now look at the content so here I say error user interrupted and gave this feedback so remember what the agent has seen in or what it has in its message list up to this point is it has an AI message where it generates a tool call for an email draft then what's going to happen is it's going to see the next message Mage is a tool call message and the content is going to be error the user interrupted and gave this feedback so the idea is that the agent should think
that it tried to send an email and that the user interrupted it and gave it some feedback that's exactly what happened and so that's how it's going to be represented it's going to be represented as this AI message and then this tool message the tool message's content is going to contain the error there's other ways you could represent this you could have an AI message then you could have another tool call message that says like sent to user and then you could have a human message which contains the Fe back this is just prompting strategies you
could do either we can see here that we have memory again ignore is similar as before now we get into what happens what happens if you edit an email what happens is you basically take the previous message the previous message that the AI generated so here we can see we're working with an AI message it has the same content as before it has the same ID as before has similar tool calls as before except the arguments are different the arguments are the one that we edited and what's basically going to happen is we're going to update the state with
this message because it has the same ID as the message that's in there before it's going to overwrite it and we'll see how this is handled in in the conditional node after the human inbox we can see here that we have similar memory we save it as a few shot example we also pass this in to an agent to reflect on what the edits were made and then if it's of accept if it's of accept great we don't we don't really do anything we save the email and this saves it as a few shot example but we don't do any more reflection because
there's no real feedback from the user to to update things on and we do not update the state with any messages uh we just return directly all right notify notify this is when it just notifies me of something interesting similar thing for notify you're allowed to ignore it you're allowed to respond to it as well you're not allowed to edit or accept it there's nothing to there's nothing to edit or accept we get the response back if we get a response from a user so if type is response then we're going to add a message which is a human message so what
the AI agent will see is it will basically see an AI message where it decide to notify as part of that also we added in some message that was like notified the user and then it will see this user message with the with whatever I typed in so that's kind of how we're doing the prompt engineering there and because there is some response we trigger some long-term memory if it ignores it we do a similar thing as before we just we just simulate as if there was a ignore uh tool call uh at the end and finally send calendar invite this is very very
similar to uh the email we're allowed to ignore it we're allowed to respond to it we are also allowed to edit it and accept it this is a calendar invite so there are some parameters that we can edit and accept and then similar thing for if we get a response we basically use this as the tool call response and simulate an error if we ignore it we simulate an ignore tool message if there's edits then we update the previous message and we call long-term memory and if it accepts then same thing not not a ton to update on the memory
side and no messages to update so I spent a lot of time on this file probably the most on this file but that's because the the the biggest thing about this agent is the fact that it's very human in Loop and that it it communicates to us it asks us questions we approve things and so this is actually where a lot of the complex logic lives and actually most of the complex logic is hidden inside lingraph and Ling graph platform because a lot of the complex logic is how do you stop at a particular point in time you then get some update
from the user but then you need the exact point in time where you were before to resume from there and to continue you need the state and you need the position in the graph speaking of the position in the graph real quickly let's check out the conditional Edge that happens after so this is enter after human let's see what's going on we can basically see that if there are are no messages this is what happens if the triage was marked as notify and there are no messages because it never it never got to the the thing that
generates messages which is the drafting email agent it was just triage step is notified there's no messages great if if we get here that means the user also didn't change it so great notifies great let's mark this as red and continue okay now if there are messages what do we do first we check if the last message is a tool message or human message so this basically happens when the user gives feedback specifically feedback in the form of responding to the assistant or telling it to do something not editing something we'll
see what happens to that later on if if it has a tool message or a human message then it goes to the draft response node this is the main agent that does everything so basically for the cases where the human responds or the human says like no this is the wrong tone the email make it XYZ it'll go back to the agent now if the last message is neither of these that means it's an AI uh message with some tool calls and these are tool calls that are either a the ones that the agent generated B the ones that the user
edited so it could be like the updated tool call with the updated content of the email that the user generated or C ones that we added based on what the user said so ignore here this is if it gets here this is always cases where I press ignore in the UI because remember we add in that fake AI message with a tool call of ignore and so now here is where we actually execute these tool calls so uh this node's responsible for executing this tool call same here all the way down all right so this covers everything in the main agent as I mentioned that's
only one of a few agents let's check out some other agents let's check out chrongraph first this is very simple this is just the cron that basically Loops through emails and triggers the other agent so we can see that it fetches emails it Loops through them there's some logic here for basically checking to see if this is an email that we already looked at um and then if it reaches the end what it does is it basically creates a run with the main agent passes in some input okay so this is a pretty simple one the more complex
one is the reflection graphs so this is still pretty experimental I only added this in the past uh week or two so to be honest this probably is the part of everything that doesn't work the best but we'll still play around with it and have some fun okay so there are four types of instructions that we are updating as the agent the tone of the email if I tell the agent to respond in a specific way or if I edit an email hopefully we should update the instructions the memory of the tone that I like response instructions these are like what content
to include in the email um or when to uh respond versus send a calendar invite or things like that scheduling is all about how to schedule things and then background instructions is basically just random information that might be useful in the future so this is is the most kind of like general form of memory this would be things it like in practice this say this has picked up things like who people are um what Lang chain or Lang graph is what roles people are at the company what their emails are things like that this is pretty General these
others are very specific to the tone of the email what the content of the email and scheduling and how get that gets done okay so what how are we doing reflection as I mentioned this is the part that doesn't work the best so all of this is absolutely just a first step I'm not claiming this is the best way to do it but what am I doing I have this General reflection prompt in here I can see that there's a few things The Prompt is basically you're helping an AI agent improve you can do this by changing their system
prompt this is their current prompt so I'm passing in their current instructions here was the agent's trajectory so if you remember in the human inbox when I called into this reflection graph I created this state as part of this state I had a list of messages this messages is basically what we are saying is the trajectory of the agent now the trajectory of the agent isn't just a list of messages it's more complex than that however for a combination of Simplicity and general Iz ability I've made it so that the trajectory by the
time it reaches this reflection graph is always a list of messages so this is where coercion from the overall state of the agent which is much more than just a list of messages this is where I make it just a list of messages that's what the trajectory will be it will be a list of messages and this list of messages will usually be something like here's an email so the the trajectory contains the content of the email and then any back and forth I have there are exceptions to this I think where I make up some additional messages to put in here's one
example in the rewriting trajectory so when the rewriting step happens I actually pass in I don't include the list of messages itself I include some different kind of like representation but the the high Lev bit is I I translate the state of the agent at some point into a list of messages for the sake of making it more General and I pass that into this en reflection step in addition I also pass in the user feedback so I have the trajectory of the agent I have the user feedback which is usually like things that I answer as
questions um or uh things that I tell it to do differently and then I have instructions for updating the prompt these are what's above so these are all instructions for updating the prompt and that's because different prompts require different instructions for how to update when I update the tone I only want to update the tone when I update the response instructions I don't want to upate the tone so I have to give some instructions for how it should it should improve the prompt based on this return an updated
prompt I should return the full prompt so if there's anything from that you want to include make sure to do that otherwise override or change anything that seems a relevant I don't need to update the prompt either so it I don't always have to be doing that and then basically so in here this is this is where the updating happens we can see that I have this update General thing I'm using 01 I've found that this is the only model that can reliably do this type of like meta prompting updating of of memories CLA on it is
okay but it errors sometimes it gets overwhelmed 4 is trash you should never use foro for updating instructions it's not good at that and then basically I call this with this schema schema is basically Logic the updated prompt or update prompt which is a Boolean of whether to update the prompt and then if this is true it should have new prompt which is a string but this isn't the only graph in here I can see that I have so this is the general reflection graph but I can see that I also have a multi-reflection
graph at the end now what's happening here basically what's going on is kind of similar we're creating kind of like a trajectory of messages but then we are asking a model to choose which types of memories to update so if we look at the prompt here we can see that it has this format you're helping an AI agent improve you can do this by changing prompts here was the agent trajectory this is same as the the step above here was the user's feedback this is same as the step above however instead of asking it to update a
specific prompt we're saying these are the types of prompts that you can update please choose the ones that are worth updating and so here we have instructions for when to choose to update the tone prompt when to choose to update the background prompt stuff like that so to recap everything what's basically happening is we have this multi-reflection graph which is triggered in the human inbox we can see that we're calling multi-reflection graph it goes in here it then tries to determine which of the four types of
memories to update it'll generate 0 to four of those memories to update and then for each of those it's calling this kind of like General reflection prompt which updates these instructions that are found for that user for that type of memory so again this is one of the newer things it doesn't work perfectly but I have found that this is already a huge Improvement into how I use the agent I don't have to tell it things multiple times it gets a sense of the tone that I like so I've generally found that the emails it's drafted are much better and
I think this is probably going to be one of the biggest unlocks in terms of letting people get started quickly with this so if you remember at the start we had to fill out this config.yml you can see here from from mine there's there's a lot of instructions in here and I updated this manually over like past six months like it's been a running list it would be great if I didn't have to do that and this was automatically generated just by me responding to it so for example like when I board in a human executive assistant they have some kind
of like instructions for how I want to respond to emails but then when they're not sure they ask me I tell them and then they they probably don't update those instructions but they at least remember or maybe they write it down maybe they do actually update the instructions so I don't have kind of like a picture perfect you know sop for um the the human EA that's built on the fly through interacting with them and that's exact what memory allows us to do and so that's why even though this isn't perfect and this messes up and there's
some changes I want to make as well like I want to change uh I have this I have this background instructions right here I looked at this the other day my background instructions are now like this long it's super long because I have all these information about who people are and things that they like but that's not that's too much information to include I want to update this to be a list of facts that we retrieve semantically at runtime maybe even some sort sort of Knowledge Graph although that's probably Overkill I don't know I
need to play around with it so the point is even though there's a lot to do here and this is just a start I'm really really excited about memory and memory stems from Human agent interaction like you cannot have this type of updating if you don't have the agent inbox to give feedback and respond to questions for this agent that we built so memory and human in the loop are super super connected and one of the nice things about lra is we have buil-in stuff for memory and built-in stuff for human in the loop it's perfect very little
infrastructure work to set it all up I feel like that's a pretty good way to end it I just got really excited about human Loop in memory and I am and so I don't really know where I can take the video from here hopefully this was a good walkr of how to set up and run the email assistant but then also how we thought about building the email assistant and things that we paid special attention to and all of that stuff thanks for watching and if you have any questions or you want to contribute to it it's open source so
please do so